# Описание проекта Tickets CRM

---

# 1. Общая архитектура

## 1.1 Разделение на 3 слоя взаимодействия

Проект логически разделён на три независимых слоя:

1. Widget (публичная форма отправки тикета)
2. REST API (/api/*)
3. Manager Web UI (админ-интерфейс)

Почему так:

- Изоляция публичного входа от внутренней панели
- Возможность использовать API независимо (мобильное приложение, SPA и т.д.)
- Простой масштабируемый контракт интеграции (iframe + API)

Это позволяет:
- менять фронтенд без изменения API
- подключать виджет к любому сайту
- масштабировать API отдельно при необходимости

---

# 2. Выбор Laravel 12

В composer.json используется:

- PHP ^8.2
- laravel/framework ^12.0
- spatie/laravel-medialibrary ^11.21
- spatie/laravel-permission ^7.2

Почему Laravel:

- Быстрая разработка CRUD
- Встроенная валидация
- Middleware
- Resource-слой
- Eloquent ORM
- Очереди, события, кэширование
- Хорошая экосистема

---

# 3. REST API как отдельный слой

Маршруты API вынесены в routes/api.php.

Причины:

- Чёткое разделение Web и API
- Stateless подход
- Возможность вынести API в отдельный сервис в будущем

API возвращает JSON через Resource-классы, что даёт:

- Контроль структуры ответа
- Отсутствие утечек внутренних полей
- Гибкость версионирования

---

# 4. Архитектура обработки тикета

## 4.1 FormRequest (StoreTicketRequest)

Валидация вынесена в отдельный класс.

Почему:

- Контроллер остаётся тонким
- Вся логика проверки централизована
- Можно легко добавлять кастомные правила

Особенности:

- Вложенная структура customer[name, phone, email]
- Regex для телефона
- Ограничение размера и типов файлов
- Ограничение количества файлов

---

## 4.2 Антиспам-ограничение (1 заявка в сутки)

Решение:

- Проверка существующих тикетов по email или phone
- Ограничение на уровне валидации

Почему не rate limiter:

- Требование бизнес-логики: ограничение по клиенту, а не по IP
- IP может быть динамическим
- Клиент может отправлять запрос с разных устройств

Такой подход:
- Бизнес-ориентирован
- Не зависит от инфраструктуры

---

# 5. Работа с файлами — Spatie Media Library

Почему выбрана именно она:

- Хранение файлов через Eloquent
- Коллекции (attachments)
- Автоматическая связь с моделью
- Возможность сменить storage (S3, local)
- Генерация URL

Преимущества:

- Нет ручной работы с путями
- Нет ручной синхронизации БД ↔ файлы
- Удобная масштабируемость

---

# 6. Ролевая модель — Spatie Permission

Почему:

- Готовая реализация ролей и прав
- Интеграция с middleware
- Минимальный код

Используются роли:

- admin
- manager

Доступ к manager UI защищён middleware.

---

# 7. Разделение Widget и Manager UI

## 7.1 Widget

- Минималистичный интерфейс
- Работает через API
- Может быть встроен через iframe

Почему iframe:

- Полная изоляция стилей
- Не конфликтует с CSS сайта клиента
- Не требует интеграции JS SDK

Это упрощает подключение:
просто вставка HTML-тега.

---

## 7.2 Manager UI

- Работает через web.php
- Использует auth + middleware manager

---

# 8. Структура данных

Основные сущности:

- Customer
- Ticket
- Media (attachments)

---

# 9. Статистика вынесена в отдельный endpoint

GET /api/tickets/statistics

---

# 10. Docker-инфраструктура

Используется:

- Nginx
- PHP-FPM
- Postgres
- Adminer

Почему Docker:

- Повторяемость окружения
- Отсутствие проблем "у меня работает"
- Быстрый запуск

Почему Postgres:

- Надёжность
- Хорошая работа с индексами
- Расширяемость

---

# 11. Подход к тестовым данным

Используются:

- Factories
- Seeders

Почему:

- Генерация реалистичных данных
- Возможность быстро поднять демо-окружение
- Простое тестирование фильтров и статистики

---

# 12. Контроллеры остаются "тонкими"

Контроллер:

- Принимает Request
- Вызывает бизнес-логику
- Возвращает Resource

Почему:

- Читаемость
- Простота тестирования
- Поддерживаемость

---

# 13. Безопасность

Решения:

- Валидация входных данных
- Ограничение типов файлов
- Ограничение размера файлов
- Ограничение частоты заявок
- Middleware auth + role

---

# 14. Возможности масштабирования

Архитектура позволяет:

- Вынести API в отдельный сервис
- Подключить S3 для хранения файлов
- Добавить очереди обработки
- Добавить WebSocket-уведомления
- Подключить внешнюю CRM

---

# 15. Сознательные упрощения

В рамках тестового задания:

- Нет сложной доменной модели
- Нет сервисного слоя
- Нет DTO
- Нет CQRS

Это сделано осознанно:

Задача — продемонстрировать:

- Чистую структуру
- Правильное разделение ответственности
- Использование зрелых библиотек
- Грамотную валидацию
- Работающий production-ready MVP

---

# 16. Итог

Проект построен как:

- Минималистичный, но расширяемый
- Production-ready MVP
- С чётким разделением публичной и внутренней зон
- С использованием проверенных библиотек вместо самописных решений

Архитектура ориентирована на:

- Простоту поддержки
- Читаемость
- Расширяемость
- Масштабирование без полной переработки


---

# 17. Использование Laravel Breeze для админки

Для реализации аутентификации в manager UI использована библиотека **Laravel Breeze**.

Почему выбран Breeze:

- Официальный starter-kit от Laravel
- Минималистичная реализация auth (без лишней сложности)
- Быстрое развертывание login / register / password reset
- Поддержка Blade + Tailwind (SSR-подход)
- Простая интеграция с middleware и ролями

Почему не самописная auth-система:

- Повышенный риск ошибок безопасности
- Потеря времени на стандартную логику
- Нет необходимости reinvent the wheel

Breeze позволил:

- Быстро настроить защищённую админ-зону
- Использовать стандартные механизмы Laravel (guards, middleware)
- Сконцентрироваться на бизнес-логике тикетов

Таким образом, админка построена на:

Laravel + Blade + Breeze + Spatie Permission

Это даёт:

- Простую архитектуру
- Прозрачную систему ролей
- Production-ready авторизацию без лишней сложности
